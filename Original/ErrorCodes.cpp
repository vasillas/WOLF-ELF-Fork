//------------------------------------------------------------------------
//  ErrorCodes.cpp
//
//  This file contains conversion routines for all the error codes
//       that can be generated by the CSound and CWave classes,
//       and by a few routines of the application itself.
// Used in:
//   - DL4YHF's Spectrum Lab
//   - the Audio Utilities
//   - the WOLF GUI
//------------------------------------------------------------------------

#include <windows.h>     // some error codes are defined HERE !

#pragma hdrstop          // no precompiled headers after this point

#include "ErrorCodes.H"  // "my" error codes are defined here..


//---------------------------------------------------------------------------
char *ErrorCodeToString(int error_code )
   // Most error codes are defined in ErrorCodes.h,
   //      some are application specific, some originate from Win32 API calls.
{
 static char unknown_msg[128];

  switch(error_code)
   {
     case NO_ERROR            :   return("no error");

     // general "wave" errors.  See "ErrorCodes.h" and <MMSYSTEM.H>:
     case WAVERR_BADFORMAT    :   return("unsupported wave format");
     case WAVERR_STILLPLAYING :   return("still something playing");
     case WAVERR_UNPREPARED   :   return("header not prepared");
     case WAVERR_SYNC         :   return("device is synchronous");

     // input wave file error codes
     case WAVIN_ERR_OPEN     :    return("can't open wave file for input");
     case WAVIN_ERR_NOTWAVE  :    return("file is not a RIFF wave type");
     case WAVIN_ERR_INVALID  :    return("invalid wave file");
     case WAVIN_ERR_NODATA   :    return("no data in file");
     case WAVIN_ERR_NOTSUPPORTED: return("not a supported data type");
     case WAVIN_ERR_READING :     return("error reading data from file");
     case WAVIN_ERR_NOTOPEN :     return("tried to read and file is not open");

     // output wave file error codes
     case WAVOUT_ERR_OPEN   :     return("can't open wave file for output");
     case WAVOUT_ERR_WRITING:     return("error writing to wave file");
     case WAVOUT_ERR_NOTOPEN:     return("tried to write and file is not open");

     // Soundcard input error codes
     case SOUNDIN_ERR_NOTOPEN:    return("tried to read and soundcard is not open");
     case SOUNDIN_ERR_OVERFLOW:   return("input buffers overflowed");
     case SOUNDIN_ERR_TIMEOUT :   return("timed out waiting for input buffers");

     // Soundcard output error codes
     case SOUNDOUT_ERR_NOTOPEN:   return("tried to write and soundcard is not open");
     case SOUNDOUT_ERR_UNDERFLOW: return("output buffers underflowed");
     case SOUNDOUT_ERR_TIMEOUT:   return("timed out waiting for output buffers");

     // general multimedia error values as defined in mmsystem.h
     case MMSYSERR_ERROR:         return("unspecified MMSYS error");
     case MMSYSERR_BADDEVICEID:   return("device ID out of range");
     case MMSYSERR_NOTENABLED:    return("driver failed enable");
     case MMSYSERR_ALLOCATED :    return("device already allocated");
     case MMSYSERR_INVALHANDLE:   return("device handle is invalid");
     case MMSYSERR_NODRIVER   :   return("no device driver present");
     case MMSYSERR_NOMEM      :   return("memory allocation error");
     case MMSYSERR_NOTSUPPORTED:  return("function isn't supported");
     case MMSYSERR_BADERRNUM   :  return("error value out of range");
     case MMSYSERR_INVALFLAG   :  return("invalid flag passed");
     case MMSYSERR_INVALPARAM  :  return("invalid parameter passed");
     case MMSYSERR_HANDLEBUSY  :  return("handle being used");
     case MMSYSERR_NODRIVERCB  :  return("driver does not call DriverCallback");

     // Other errors...
     case ERROR_WORD_AT_ODD_ADDRESS: return ("word at odd address");
     case ERROR_THREAD_FAILED:       return ("worker thread failed");
     case ERROR_PIPE_FAILED  :       return ("communication pipe failed");
     case ERROR_UNKNOWN_CMD_ARGUMENT:  return ("unknown command argument");
     case ERROR_ILLEGAL_CMD_PARAMETER: return ("illegal parameter value");
     case ERROR_CMD_COMBI_UNSUPPORTED:    return ("command combination not supported");
     case ERROR_DATA_TYPE_NOT_SUPPORTED:  return ("data type not supported");
     case ERROR_OUTPUT_FILE_NOT_CONSUMED: return ("output file not consumed");
     case ERROR_CREATE_FILE_FAILED:  return ("CreateFile failed");
     case ERROR_FILE_DOESNT_EXIST:   return ("File doesnt exist");

     case MEMORY_ERROR         :     return("Memory error");

     default:  // unknown MMSYSTEM error code:
      {    // try to make the best of it, maybe the OS knows what it means..
        LPVOID lpMsgBuf;
        DWORD  dwLength;

        /* Convert the GetLastError()-code into a readable string: */
        if( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               error_code,   // 'int' has 32 bit, here: DWORD expected
               0,
              (LPTSTR)&lpMsgBuf,
               0,
               NULL) == 0)
          { /* failed to format the message */
            wsprintf(unknown_msg, "unknown error #%d", error_code);
          }
        else // FormatMessage() successfull ..
          {
           // Convert the string and free the message's buffer.
           strncpy(unknown_msg, (char*)lpMsgBuf, sizeof(unknown_msg)-1);
           unknown_msg[sizeof(unknown_msg)-1] = '\0'; // keep string terminated

           // Free the buffer which has been allocated somehow in FormatMessage(!)
           LocalFree( lpMsgBuf );

           // If the result string contains this foolish CR and/or NL characters at the end,
           // trow them out.. they are UTTERLY USELESS in 99.9999 % of all cases !
           dwLength = strlen(unknown_msg);
           if( (dwLength>0) && (unknown_msg[dwLength-1] == '\r') )  // crazy1
            { --dwLength;
              unknown_msg[dwLength] =  '\0';
            }
           if( (dwLength>0) && (unknown_msg[dwLength-1] == '\n') )  // crazy2
            { --dwLength;
              unknown_msg[dwLength] =  '\0';
            }
           if( (dwLength>0) && (unknown_msg[dwLength-1] == '\r') )  // crazy3
            { --dwLength;
              unknown_msg[dwLength] =  '\0';
            }
         }
        return unknown_msg;
      }
   }
} // end ErrorCodeToString()
